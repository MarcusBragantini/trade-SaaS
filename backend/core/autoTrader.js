const WebSocket = require('ws');
const RiskManager = require('./riskManager');
const StrategyEngine = require('./strategy');

class AutoTrader {
    constructor(userId, derivToken) {
        this.userId = userId;
        this.derivToken = derivToken;
        this.riskManager = new RiskManager();
        this.strategy = new StrategyEngine();
        this.ws = null;
        this.isConnected = false;
        this.isTrading = false;
        this.isRunning = false;
        this.currentSymbol = 'BTCUSD';
        this.stake = 10;
        this.duration = 5;
        this.durationUnit = 'm';
        this.lastPrice = null;
        this.priceHistory = [];
        this.maxHistory = 50;
        
        // Configura√ß√µes da IA
        this.useAI = false;
        this.aiTrader = null;
        this.aiConfidence = 0.7;
        this.aiAnalysisInterval = 60000; // 1 minuto
        this.aiAnalysisTimer = null;
        this.lastAISignal = null;
        
        // M√©tricas
        this.tradesToday = 0;
        this.maxTradesPerDay = 10;
        this.totalProfit = 0;
        this.winningTrades = 0;
        this.losingTrades = 0;
    }

    // Conectar ao WebSocket da Deriv
    async connect() {
        return new Promise((resolve, reject) => {
            try {
                this.ws = new WebSocket('wss://ws.binaryws.com/websockets/v3?app_id=1089');
                
                this.ws.on('open', () => {
                    console.log('üîå Conectado ao WebSocket da Deriv');
                    this.isConnected = true;
                    this.authenticate();
                    resolve();
                });

                this.ws.on('message', (data) => {
                    this.handleMessage(JSON.parse(data));
                });

                this.ws.on('error', (error) => {
                    console.error('‚ùå Erro WebSocket:', error);
                    this.isConnected = false;
                    reject(error);
                });

                this.ws.on('close', () => {
                    console.log('üîå Conex√£o WebSocket fechada');
                    this.isConnected = false;
                });

            } catch (error) {
                console.error('‚ùå Erro ao conectar:', error);
                reject(error);
            }
        });
    }

    // Autenticar
    authenticate() {
        if (!this.ws || !this.isConnected) return;

        console.log('üîë Autenticando...');
        this.ws.send(JSON.stringify({
            authorize: this.derivToken
        }));
    }

    // Iniciar trading autom√°tico
    startTrading(symbol = 'BTCUSD', stake = 10, duration = 5, durationUnit = 'm') {
        if (!this.isConnected) {
            console.log('‚ùå N√£o conectado ao WebSocket');
            return false;
        }

        this.currentSymbol = symbol;
        this.stake = stake;
        this.duration = duration;
        this.durationUnit = durationUnit;
        this.isTrading = true;

        console.log(`üöÄ Iniciando trading autom√°tico:`);
        console.log(`   S√≠mbolo: ${symbol}`);
        console.log(`   Stake: $${stake}`);
        console.log(`   Dura√ß√£o: ${duration}${durationUnit}`);

        // Solicitar ticks do s√≠mbolo
        this.ws.send(JSON.stringify({
            ticks: symbol
        }));

        return true;
    }

    // Parar trading autom√°tico
    stopTrading() {
        this.isTrading = false;
        console.log('‚èπÔ∏è Trading autom√°tico parado');
    }

    // Processar mensagens do WebSocket
    handleMessage(data) {
        if (data.msg_type === 'authorize') {
            console.log('‚úÖ Autenticado com sucesso!');
            if (this.isTrading) {
                this.ws.send(JSON.stringify({ ticks: this.currentSymbol }));
            }
        }

        if (data.msg_type === 'tick' && this.isTrading) {
            this.handleTick(data.tick);
        }

        if (data.msg_type === 'proposal' && this.isTrading) {
            this.handleProposal(data.proposal);
        }

        if (data.msg_type === 'buy' && this.isTrading) {
            this.handleBuyResponse(data.buy);
        }

        if (data.error) {
            console.error('‚ùå Erro API:', data.error.message, 'C√≥digo:', data.error.code);
        }
    }

    // Processar tick de pre√ßo
    handleTick(tick) {
        if (!tick || !tick.quote) {
            console.log('‚ö†Ô∏è Tick inv√°lido recebido:', tick);
            return;
        }
        
        const price = parseFloat(tick.quote);
        this.lastPrice = price;
        
        // Adicionar ao hist√≥rico
        this.priceHistory.push(price);
        if (this.priceHistory.length > this.maxHistory) {
            this.priceHistory.shift();
        }

        console.log(`üìä Tick ${this.currentSymbol}: $${price.toFixed(4)}`);

        // Verificar se pode fazer trade
        if (!this.riskManager.canTrade(this.stake)) {
            console.log('üö´ Trade bloqueado pelo gerenciador de risco');
            return;
        }

        // Decidir dire√ß√£o usando estrat√©gia
        const direction = this.strategy.decidir(this.priceHistory);
        
        // Solicitar proposta
        this.ws.send(JSON.stringify({
            proposal: 1,
            amount: this.stake,
            basis: 'stake',
            contract_type: direction,
            currency: 'USD',
            duration: this.duration,
            duration_unit: this.durationUnit,
            symbol: this.currentSymbol
        }));
    }

    // Processar proposta
    handleProposal(proposal) {
        console.log('üí∞ Proposta recebida:', JSON.stringify(proposal, null, 2));
        
        if (proposal && proposal.ask_price && proposal.id) {
            // Executar compra
            this.ws.send(JSON.stringify({
                buy: proposal.id,
                price: proposal.ask_price
            }));
        } else {
            console.log('‚ö†Ô∏è Proposta inv√°lida ou incompleta');
        }
    }

    // Processar resposta de compra
    handleBuyResponse(buy) {
        console.log(`üéØ Ordem executada! Contrato: ${buy.contract_id}`);
        
        // Simular resultado ap√≥s dura√ß√£o (em produ√ß√£o, usar WebSocket para resultado real)
        setTimeout(() => {
            this.simulateTradeResult(buy.contract_id);
        }, this.duration * (this.durationUnit === 'm' ? 60000 : 1000));
    }

    // Simular resultado do trade (para demonstra√ß√£o)
    simulateTradeResult(contractId) {
        const profit = Math.random() > 0.5 ? this.stake * 0.8 : -this.stake;
        
        console.log(`üìà Trade ${contractId} finalizado: $${profit.toFixed(2)}`);
        
        // Registrar no gerenciador de risco
        this.riskManager.recordTrade(this.stake, profit);
        
        // Log estat√≠sticas
        const stats = this.riskManager.getStats();
        console.log(`üìä Estat√≠sticas: ${stats.trades} trades, ${stats.winRate}% win rate`);
    }

    // Configurar par√¢metros
    configure(symbol, stake, duration, durationUnit, strategy) {
        this.currentSymbol = symbol;
        this.stake = stake;
        this.duration = duration;
        this.durationUnit = durationUnit;
        
        if (strategy) {
            this.strategy.setStrategy(strategy);
        }

        console.log('‚öôÔ∏è Configura√ß√£o atualizada:', {
            symbol,
            stake,
            duration,
            durationUnit,
            strategy: this.strategy.currentStrategy
        });
    }

    // Obter status
    getStatus() {
        return {
            isConnected: this.isConnected,
            isTrading: this.isTrading,
            currentSymbol: this.currentSymbol,
            stake: this.stake,
            duration: this.duration,
            durationUnit: this.durationUnit,
            lastPrice: this.lastPrice,
            riskStats: this.riskManager.getStats(),
            strategyStats: this.strategy.getStrategyStats()
        };
    }

    // Desconectar
    disconnect() {
        if (this.ws) {
            this.ws.close();
            this.ws = null;
        }
        this.isConnected = false;
        this.isTrading = false;
        this.isRunning = false;
        
        // Parar an√°lise da IA
        if (this.aiAnalysisTimer) {
            clearInterval(this.aiAnalysisTimer);
            this.aiAnalysisTimer = null;
        }
        
        console.log('üîå Desconectado do WebSocket');
    }

    // Iniciar auto-trading
    async start(config = {}) {
        try {
            console.log(`üöÄ Iniciando auto-trading para usu√°rio ${this.userId}`);
            
            // Configurar par√¢metros
            this.useAI = config.useAI || false;
            this.aiTrader = config.aiTrader || null;
            this.aiConfidence = config.aiConfidence || 0.7;
            this.maxTradesPerDay = config.maxTradesPerDay || 10;
            this.currentSymbol = config.symbols?.[0] || 'BTCUSD';
            
            if (this.useAI && this.aiTrader) {
                console.log('ü§ñ Modo IA ativado');
                this.startAIAnalysis();
            }
            
            // Conectar ao WebSocket
            await this.connect();
            
            // Iniciar trading
            this.isRunning = true;
            this.isTrading = true;
            
            console.log(`‚úÖ Auto-trading iniciado com sucesso`);
            
        } catch (error) {
            console.error('‚ùå Erro ao iniciar auto-trading:', error);
            throw error;
        }
    }

    // Parar auto-trading
    async stop() {
        try {
            console.log(`‚èπÔ∏è Parando auto-trading para usu√°rio ${this.userId}`);
            
            this.isRunning = false;
            this.isTrading = false;
            
            // Parar an√°lise da IA
            if (this.aiAnalysisTimer) {
                clearInterval(this.aiAnalysisTimer);
                this.aiAnalysisTimer = null;
            }
            
            // Desconectar WebSocket
            this.disconnect();
            
            console.log(`‚úÖ Auto-trading parado com sucesso`);
            
        } catch (error) {
            console.error('‚ùå Erro ao parar auto-trading:', error);
            throw error;
        }
    }

    // Iniciar an√°lise da IA
    startAIAnalysis() {
        if (!this.useAI || !this.aiTrader) return;
        
        console.log('ü§ñ Iniciando an√°lise cont√≠nua da IA');
        
        this.aiAnalysisTimer = setInterval(async () => {
            try {
                if (!this.isRunning || !this.isTrading) return;
                
                // Verificar limite de trades di√°rios
                if (this.tradesToday >= this.maxTradesPerDay) {
                    console.log('üìä Limite de trades di√°rios atingido');
                    return;
                }
                
                // Analisar mercado com IA
                const signal = await this.aiTrader.analyzeMarket(this.currentSymbol);
                
                if (signal && signal.action !== 'HOLD' && signal.confidence >= this.aiConfidence) {
                    console.log(`üéØ Sinal da IA: ${signal.action} com ${(signal.confidence * 100).toFixed(1)}% de confian√ßa`);
                    
                    // Armazenar sinal
                    this.lastAISignal = signal;
                    
                    // Executar trade baseado no sinal da IA
                    await this.executeAITrade(signal);
                } else if (signal) {
                    console.log(`‚è∏Ô∏è IA recomenda aguardar (confian√ßa: ${(signal.confidence * 100).toFixed(1)}%)`);
                }
                
            } catch (error) {
                console.error('‚ùå Erro na an√°lise da IA:', error);
            }
        }, this.aiAnalysisInterval);
    }

    // Executar trade baseado no sinal da IA
    async executeAITrade(signal) {
        try {
            console.log(`üéØ Executando trade baseado no sinal da IA: ${signal.action}`);
            
            // Mapear a√ß√£o da IA para tipo de trade
            const tradeType = signal.action === 'BUY' ? 'CALL' : 'PUT';
            
            // Executar trade
            const result = await this.executeTrade(tradeType, signal);
            
            if (result) {
                this.tradesToday++;
                console.log(`‚úÖ Trade executado com sucesso (${this.tradesToday}/${this.maxTradesPerDay})`);
                
                // Atualizar m√©tricas
                this.updateMetrics(result);
                
                // Atualizar IA com resultado
                if (this.aiTrader) {
                    this.aiTrader.updatePerformance({
                        id: result.id,
                        profit: result.profit,
                        symbol: this.currentSymbol,
                        type: tradeType,
                        timestamp: Date.now()
                    });
                }
            }
            
        } catch (error) {
            console.error('‚ùå Erro ao executar trade da IA:', error);
        }
    }

    // Executar trade
    async executeTrade(type, signal = null) {
        try {
            if (!this.isConnected) {
                throw new Error('WebSocket n√£o conectado');
            }
            
            // Preparar dados do trade
            const tradeData = {
                symbol: this.currentSymbol,
                type: type,
                amount: this.stake,
                duration: this.duration,
                duration_unit: this.durationUnit
            };
            
            // Usar stop loss e take profit da IA se dispon√≠vel
            if (signal && signal.stopLoss) {
                tradeData.stopLoss = signal.stopLoss;
            }
            if (signal && signal.takeProfit) {
                tradeData.takeProfit = signal.takeProfit;
            }
            
            console.log(`üìä Executando trade:`, tradeData);
            
            // Enviar proposta
            this.ws.send(JSON.stringify({
                proposal: 1,
                ...tradeData
            }));
            
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('Timeout na execu√ß√£o do trade'));
                }, 10000);
                
                // Handler tempor√°rio para capturar resultado
                const originalHandler = this.handleMessage.bind(this);
                this.handleMessage = (data) => {
                    originalHandler(data);
                    
                    if (data.msg_type === 'buy') {
                        clearTimeout(timeout);
                        resolve({
                            id: data.buy.contract_id,
                            profit: 0, // Ser√° atualizado quando o contrato finalizar
                            timestamp: Date.now()
                        });
                        this.handleMessage = originalHandler;
                    }
                };
            });
            
        } catch (error) {
            console.error('‚ùå Erro ao executar trade:', error);
            throw error;
        }
    }

    // Atualizar m√©tricas
    updateMetrics(tradeResult) {
        this.totalProfit += tradeResult.profit;
        
        if (tradeResult.profit > 0) {
            this.winningTrades++;
        } else {
            this.losingTrades++;
        }
        
        console.log(`üìä M√©tricas atualizadas: Lucro total: $${this.totalProfit.toFixed(2)}, Trades: ${this.winningTrades}W/${this.losingTrades}L`);
    }

    // Obter estat√≠sticas (atualizado)
    getStats() {
        return {
            isRunning: this.isRunning,
            isTrading: this.isTrading,
            useAI: this.useAI,
            aiConfidence: this.aiConfidence,
            currentSymbol: this.currentSymbol,
            tradesToday: this.tradesToday,
            maxTradesPerDay: this.maxTradesPerDay,
            totalProfit: this.totalProfit,
            winningTrades: this.winningTrades,
            losingTrades: this.losingTrades,
            winRate: this.winningTrades + this.losingTrades > 0 ? 
                (this.winningTrades / (this.winningTrades + this.losingTrades)) * 100 : 0,
            lastAISignal: this.lastAISignal,
            lastPrice: this.lastPrice,
            riskStats: this.riskManager.getStats(),
            strategyStats: this.strategy.getStrategyStats()
        };
    }
}

module.exports = AutoTrader;
