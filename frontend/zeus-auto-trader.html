<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Titan Auto Trader - Simples</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 10px;
        }

        .header h1 {
            color: #00ff88;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #2a2a2a;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .status-indicator {
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
        }

        .status-running {
            background: #00ff88;
            color: #000;
        }

        .status-stopped {
            background: #ff4444;
            color: white;
        }

        .balance {
            font-size: 1.2em;
            color: #00ff88;
        }

        .deriv-status {
            font-size: 1em;
            color: #4488ff;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .switch-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
        }

        .switch-btn:hover {
            background: #45a049;
        }

        /* Sistema de Notifica√ß√µes Profissionais */
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            max-width: 400px;
            width: calc(100vw - 40px);
        }

        .notification {
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            margin-bottom: 10px;
            padding: 16px 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
            border-left: 4px solid;
            min-height: 60px;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            border-left-color: #4CAF50;
            background: linear-gradient(135deg, #f8fff8 0%, #e8f5e8 100%);
        }

        .notification.error {
            border-left-color: #f44336;
            background: linear-gradient(135deg, #fff8f8 0%, #ffe8e8 100%);
        }

        .notification.warning {
            border-left-color: #ff9800;
            background: linear-gradient(135deg, #fffaf0 0%, #fff3e0 100%);
        }

        .notification.info {
            border-left-color: #2196F3;
            background: linear-gradient(135deg, #f0f8ff 0%, #e3f2fd 100%);
        }

        .notification-icon {
            font-size: 20px;
            flex-shrink: 0;
            min-width: 24px;
        }

        .notification-content {
            flex: 1;
            min-width: 0;
        }

        .notification-title {
            font-weight: 600;
            margin: 0 0 4px 0;
            color: #333;
            font-size: 14px;
            word-wrap: break-word;
        }

        .notification-message {
            margin: 0;
            color: #666;
            font-size: 13px;
            line-height: 1.4;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .notification-close {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #999;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s;
            flex-shrink: 0;
            touch-action: manipulation;
        }

        .notification-close:hover {
            background-color: rgba(0, 0, 0, 0.1);
            color: #666;
        }

        /* Responsividade para Notifica√ß√µes */
        @media (max-width: 768px) {
            .notification-container {
                top: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
                width: auto;
            }

            .notification {
                padding: 12px 16px;
                gap: 10px;
                min-height: 50px;
            }

            .notification-icon {
                font-size: 18px;
                min-width: 20px;
            }

            .notification-title {
                font-size: 13px;
            }

            .notification-message {
                font-size: 12px;
            }

            .notification-close {
                width: 20px;
                height: 20px;
                font-size: 16px;
            }
        }

        @media (max-width: 480px) {
            .notification-container {
                top: 5px;
                right: 5px;
                left: 5px;
            }

            .notification {
                padding: 10px 12px;
                gap: 8px;
                min-height: 45px;
            }

            .notification-icon {
                font-size: 16px;
                min-width: 18px;
            }

            .notification-title {
                font-size: 12px;
                margin-bottom: 2px;
            }

            .notification-message {
                font-size: 11px;
                line-height: 1.3;
            }

            .notification-close {
                width: 18px;
                height: 18px;
                font-size: 14px;
            }
        }

        .deriv-connected {
            color: #00ff88;
        }

        .deriv-disconnected {
            color: #ff4444;
        }

        .control-panel {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .form-row {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            align-items: end;
            flex-wrap: wrap;
        }

        @media (max-width: 768px) {
            .form-row {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
        }

        .form-group {
            flex: 1;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            background: #333;
            color: white;
            font-size: 16px;
        }

        .form-group select optgroup {
            background: #2a2a2a;
            color: #00ff88;
            font-weight: bold;
            padding: 5px;
        }

        .form-group select option {
            background: #333;
            color: white;
            padding: 8px;
        }

        .form-group select option:hover {
            background: #444;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 100px;
            text-align: center;
        }

        @media (max-width: 768px) {
            .btn {
                width: 100%;
                margin: 5px 0;
                padding: 15px 20px;
                font-size: 16px;
            }
        }

        .btn-start {
            background: #00ff88;
            color: #000;
        }

        .btn-stop {
            background: #ff4444;
            color: white;
        }

        .btn-test {
            background: #4488ff;
            color: white;
        }

        .btn-config {
            background: #9c27b0;
            color: white;
        }

        .btn-config:hover {
            background: #7b1fa2;
        }

        /* Configura√ß√µes do Cliente */
        .config-panel {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid #444;
        }

        .config-panel h3 {
            color: #00ff88;
            margin-bottom: 20px;
            text-align: center;
        }

        .config-sections {
            display: grid;
            gap: 20px;
        }

        .config-section {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #555;
        }

        .config-section h4 {
            color: #00ff88;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .config-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .config-actions .btn {
            min-width: 120px;
        }

        #trading-pairs {
            min-height: 100px;
        }

        #trading-pairs option {
            padding: 5px;
        }

        /* Responsividade para Configura√ß√µes */
        @media (max-width: 768px) {
            .config-sections {
                gap: 15px;
            }

            .config-section {
                padding: 12px;
            }

            .config-actions {
                flex-direction: column;
                align-items: center;
            }

            .config-actions .btn {
                width: 100%;
                max-width: 200px;
            }
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        @media (max-width: 768px) {
            .btn-group {
                flex-direction: column;
                gap: 5px;
            }
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #00ff88;
        }

        .stat-label {
            color: #ccc;
            font-size: 0.9em;
        }

        .trades-container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .trade-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            background: #333;
        }

        .trade-win {
            border-left: 4px solid #00ff88;
        }

        .trade-loss {
            border-left: 4px solid #ff4444;
        }

        .logs {
            background: #000;
            padding: 15px;
            border-radius: 10px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }

        .log-entry {
            margin: 2px 0;
            padding: 2px 0;
        }

        .log-time {
            color: #666;
        }

        .log-success {
            color: #00ff88;
        }

        .log-error {
            color: #ff4444;
        }

        .log-info {
            color: #4488ff;
        }

        .pulse {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <!-- Container de Notifica√ß√µes -->
    <div id="notification-container" class="notification-container"></div>

    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>‚ö° ZEUS AUTO TRADER</h1>
            <p>Trading Automatizado com IA</p>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div id="status-indicator" class="status-indicator status-stopped">
                üî¥ PARADO
            </div>
            <div id="deriv-status" class="deriv-status">
                <span id="deriv-connection">Verificando...</span>
                <button id="switch-account-btn" class="switch-btn" onclick="switchAccount()">üîÑ Trocar Conta</button>
            </div>
            <div class="balance">
                Saldo: <span id="balance">$0.00</span>
            </div>
        </div>

        <!-- Control Panel -->
        <div class="control-panel">
            <div class="form-row">
                <div class="form-group">
                    <label>Par:</label>
                    <select id="pair">
                        <optgroup label="Synthetic Indices (24/7)">
                            <option value="R_10" selected>Rise/Fall 10</option>
                            <option value="R_25">Rise/Fall 25</option>
                            <option value="R_50">Rise/Fall 50</option>
                            <option value="R_75">Rise/Fall 75</option>
                            <option value="R_100">Rise/Fall 100</option>
                        </optgroup>
                        <optgroup label="Major Forex">
                            <option value="EURUSD">EUR/USD</option>
                            <option value="GBPUSD">GBP/USD</option>
                            <option value="USDJPY">USD/JPY</option>
                            <option value="AUDUSD">AUD/USD</option>
                            <option value="USDCAD">USD/CAD</option>
                            <option value="USDCHF">USD/CHF</option>
                            <option value="NZDUSD">NZD/USD</option>
                        </optgroup>
                        <optgroup label="Crypto">
                            <option value="BTCUSD">BTC/USD</option>
                            <option value="ETHUSD">ETH/USD</option>
                            <option value="LTCUSD">LTC/USD</option>
                        </optgroup>
                        <optgroup label="Commodities">
                            <option value="GOLD">Gold</option>
                            <option value="SILVER">Silver</option>
                            <option value="OIL">Oil</option>
                        </optgroup>
                    </select>
                </div>
                <div class="form-group">
                    <label>Valor:</label>
                    <input type="number" id="amount" value="5" min="1" max="100">
                </div>
                <div class="form-group">
                    <div class="btn-group">
                        <button id="start-btn" class="btn btn-start">üöÄ INICIAR</button>
                        <button id="stop-btn" class="btn btn-stop" disabled>‚èπÔ∏è PARAR</button>
                        <button id="test-trade-btn" class="btn btn-test">üß™ TESTE</button>
                        <button id="config-btn" class="btn btn-config">‚öôÔ∏è CONFIG</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Stats -->
        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="total-trades">0</div>
                <div class="stat-label">Total Trades</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="win-rate">0%</div>
                <div class="stat-label">Win Rate</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="profit">$0.00</div>
                <div class="stat-label">Lucro Total</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="daily-profit">$0.00</div>
                <div class="stat-label">Lucro Di√°rio</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="active-trades">0</div>
                <div class="stat-label">Ativos</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="martingale-level">0</div>
                <div class="stat-label">Martingale</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="queue-size">0</div>
                <div class="stat-label">Fila</div>
            </div>
        </div>

        <!-- Configura√ß√µes do Cliente -->
        <div id="config-panel" class="config-panel" style="display: none;">
            <h3>‚öôÔ∏è Configura√ß√µes do Cliente</h3>
            
            <div class="config-sections">
                <!-- Se√ß√£o de Risk Management -->
                <div class="config-section">
                    <h4>üõ°Ô∏è Gest√£o de Risco</h4>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="stop-win">Stop Win ($):</label>
                            <input type="number" id="stop-win" value="50" min="0" max="1000">
                        </div>
                        <div class="form-group">
                            <label for="stop-loss">Stop Loss ($):</label>
                            <input type="number" id="stop-loss" value="100" min="0" max="1000">
                        </div>
                        <div class="form-group">
                            <label for="risk-per-trade">Risco por Trade (%):</label>
                            <input type="number" id="risk-per-trade" value="1" min="0.1" max="10" step="0.1">
                        </div>
                    </div>
                </div>

                <!-- Se√ß√£o de Martingale -->
                <div class="config-section">
                    <h4>üìà Martingale</h4>
                    <div class="form-row">
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="martingale-enabled"> Habilitar Martingale
                            </label>
                        </div>
                        <div class="form-group">
                            <label for="martingale-multiplier">Multiplicador:</label>
                            <input type="number" id="martingale-multiplier" value="2.0" min="1.1" max="5.0" step="0.1">
                        </div>
                        <div class="form-group">
                            <label for="max-martingale-levels">M√°x. N√≠veis:</label>
                            <input type="number" id="max-martingale-levels" value="3" min="1" max="10">
                        </div>
                    </div>
                </div>

                <!-- Se√ß√£o de Trading -->
                <div class="config-section">
                    <h4>üíπ Trading</h4>
                    <div class="form-row">
                     <div class="form-group">
                         <label for="trade-amount">Valor do Trade ($):</label>
                         <input type="number" id="trade-amount" value="5" min="1" max="1000">
                     </div>
                     <div class="form-group">
                         <label for="ticket-quantity">Quantidade de Tickets:</label>
                         <input type="number" id="ticket-quantity" value="10" min="1" max="100">
                     </div>
                        <div class="form-group">
                            <label for="max-daily-trades">M√°x. Trades/Dia:</label>
                            <input type="number" id="max-daily-trades" value="50" min="1" max="1000">
                        </div>
                        <div class="form-group">
                            <label for="trading-pairs">Pares Ativos:</label>
                            <select id="trading-pairs" multiple>
                                <option value="R_10" selected>Rise/Fall 10</option>
                                <option value="R_25" selected>Rise/Fall 25</option>
                                <option value="R_50" selected>Rise/Fall 50</option>
                                <option value="R_75">Rise/Fall 75</option>
                                <option value="R_100">Rise/Fall 100</option>
                                <option value="EURUSD">EUR/USD</option>
                                <option value="GBPUSD">GBP/USD</option>
                                <option value="BTCUSD">BTC/USD</option>
                                <option value="ETHUSD">ETH/USD</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Se√ß√£o de IA -->
                <div class="config-section">
                    <h4>ü§ñ Intelig√™ncia Artificial</h4>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="ai-confidence-threshold">Limiar de Confian√ßa (%):</label>
                            <input type="number" id="ai-confidence-threshold" value="60" min="10" max="100">
                        </div>
                     <div class="form-group">
                         <label for="ai-analysis-interval">Intervalo de An√°lise (s):</label>
                         <input type="number" id="ai-analysis-interval" value="10" min="5" max="60">
                     </div>
                     <div class="form-group">
                         <label for="trade-cooldown">Cooldown entre Trades (s):</label>
                         <input type="number" id="trade-cooldown" value="5" min="1" max="30">
                     </div>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="auto-trading-enabled"> Trading Autom√°tico
                            </label>
                        </div>
                    </div>
                </div>

                <!-- Se√ß√£o de Hor√°rios -->
                <div class="config-section">
                    <h4>üïê Hor√°rios de Trading</h4>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="trading-hours-start">In√≠cio:</label>
                            <input type="time" id="trading-hours-start" value="00:00">
                        </div>
                        <div class="form-group">
                            <label for="trading-hours-end">Fim:</label>
                            <input type="time" id="trading-hours-end" value="23:59">
                        </div>
                    </div>
                </div>
            </div>

            <div class="config-actions">
                <button id="save-config-btn" class="btn btn-success">üíæ Salvar</button>
                <button id="reset-config-btn" class="btn btn-warning">üîÑ Resetar</button>
                <button id="close-config-btn" class="btn btn-secondary">‚ùå Fechar</button>
            </div>
        </div>

        <!-- Recent Trades -->
        <div class="trades-container">
            <h3>üìà Trades Recentes</h3>
            <div id="trades-list">
                <div style="text-align: center; color: #666; padding: 20px;">
                    Nenhum trade executado
                </div>
            </div>
        </div>

        <!-- Logs -->
        <div class="logs" id="logs">
            <div class="log-entry">
                <span class="log-time">[Sistema]</span>
                <span class="log-info">Titan Auto Trader iniciado</span>
            </div>
        </div>
    </div>

    <script src="js/config.js"></script>
    <script src="js/auth.js"></script>
    
    <script>
        class TitanSimple {
            constructor() {
                this.isRunning = false;
                this.trades = [];
                this.stats = {
                    totalTrades: 0,
                    winningTrades: 0,
                    totalProfit: 0,
                    activeTrades: 0
                };
                this.interval = null;
                this.apiBase = 'http://localhost:5001/api/v1';
                this.derivConnected = false;
                this.realBalance = 0;
                this.productionMode = true; // Modo produ√ß√£o - logs importantes apenas
                this.realtimeAnalysisActive = false;
                this.lastAnalysisTime = null;
                this.activeTrades = new Map(); // Monitorar trades ativos
                this.dailyStats = {
                    trades: 0,
                    profit: 0,
                    startTime: new Date()
                };
                this.martingaleLevel = 0; // N√≠vel atual do martingale
                this.consecutiveLosses = 0; // Perdas consecutivas
                this.config = {}; // Configura√ß√µes do cliente
                this.tradeQueue = []; // Fila de trades pendentes
                this.isExecutingTrade = false; // Flag para evitar execu√ß√µes simult√¢neas
                this.lastTradeTime = 0; // Timestamp do √∫ltimo trade
                this.tradeCooldown = 5000; // 5 segundos entre trades
            }

            async init() {
                this.log('‚ö° Inicializando Zeus Auto Trader...', 'info');
                await this.loadClientConfig();
                this.setupEvents();
                this.updateUI();
                this.log('‚úÖ Sistema inicializado - aguardando verifica√ß√£o Deriv...', 'success');
            }

            async loadClientConfig() {
                try {
                    const token = this.getAuthToken();
                    if (!token) {
                        this.log('‚ö†Ô∏è Token n√£o encontrado para carregar configura√ß√µes', 'warning');
                        return;
                    }

                    const response = await fetch(`${this.apiBase}/client-config/config`, {
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (response.ok) {
                        const result = await response.json();
                        if (result.status === 'success') {
                            this.config = result.data;
                            // Aplicar cooldown configurado
                            this.tradeCooldown = (this.config.tradeCooldown || 5) * 1000; // Converter para ms
                            this.log('‚úÖ Configura√ß√µes do cliente carregadas', 'success');
                        }
                    }
                } catch (error) {
                    this.log(`‚ö†Ô∏è Erro ao carregar configura√ß√µes: ${error.message}`, 'warning');
                }
            }

            setupEvents() {
                document.getElementById('start-btn').addEventListener('click', () => this.start());
                document.getElementById('stop-btn').addEventListener('click', () => this.stop());
                document.getElementById('test-trade-btn').addEventListener('click', () => this.testTrade());
            }

            async testTrade() {
                this.log('üß™ Testando trade manual...', 'info');
                const pair = document.getElementById('pair').value;
                
                // Criar sinal de teste com alta confian√ßa
                const testSignal = {
                    symbol: pair,
                    action: 'BUY',
                    confidence: 0.8
                };
                
                this.log(`üß™ Sinal de teste: ${testSignal.action} ${testSignal.symbol} (${(testSignal.confidence * 100).toFixed(0)}%)`, 'info');
                await this.executeTrade(testSignal);
            }

            async start() {
                if (this.isRunning) return;

                this.isRunning = true;
                this.updateStatus('running');
                this.log('üöÄ Trading autom√°tico iniciado!', 'success');

                // An√°lise a cada 10 segundos
                this.interval = setInterval(() => {
                    this.analyzeAndTrade();
                }, 10000);

                // Atualizar saldo a cada 30 segundos
                this.balanceInterval = setInterval(() => {
                    if (this.derivConnected) {
                        this.updateBalance();
                    }
                }, 30000);

                // Iniciar an√°lise em tempo real
                await this.startRealtimeAnalysis();

                // Primeira an√°lise
                this.analyzeAndTrade();
            }

            stop() {
                this.isRunning = false;
                this.updateStatus('stopped');
                
                if (this.interval) {
                    clearInterval(this.interval);
                    this.interval = null;
                }

                if (this.balanceInterval) {
                    clearInterval(this.balanceInterval);
                    this.balanceInterval = null;
                }

                // Parar an√°lise em tempo real
                this.stopRealtimeAnalysis();

                this.log('‚èπÔ∏è Trading autom√°tico parado', 'error');
            }

            async analyzeAndTrade() {
                if (!this.isRunning) return;

                try {
                    // An√°lise t√©cnica da IA
                    const signal = await this.generateSignal();
                    
                    // Validar sinal antes de processar
                    if (!signal || !signal.action || signal.confidence === undefined) {
                        this.log(`‚ùå Sinal inv√°lido recebido: ${JSON.stringify(signal)}`, 'error');
                        return;
                    }
                    
                    // Log do sinal para debug
                    this.log(`üîç Sinal: ${signal.action} ${signal.symbol} (${signal.confidence}%)`, 'info');

                    // Verificar se deve executar trade baseado em confian√ßa e risco
                    const minConfidence = 30; // M√≠nimo 30% de confian√ßa (reduzido para mais trades)
                    const shouldTrade = signal.confidence >= minConfidence && signal.action !== 'HOLD';
                    
                    // Verificar n√≠vel de risco
                    if (signal.riskLevel === 'HIGH') {
                        this.log(`‚ö†Ô∏è Risco alto detectado - Trade cancelado: ${signal.action} (${signal.confidence}%)`, 'warning');
                        return;
                    }
                    
                    if (shouldTrade) {
                        this.log(`‚úÖ Adicionando trade √† fila: ${signal.action} (${signal.confidence}%) - Risco: ${signal.riskLevel || 'MEDIUM'}`, 'info');
                        this.addTradeToQueue(signal);
                    } else {
                        const reason = signal.action === 'HOLD' ? 'HOLD' : 
                                     signal.confidence < minConfidence ? `Confian√ßa baixa (${signal.confidence}% < ${minConfidence}%)` : 'Outros motivos';
                        this.log(`‚è∏Ô∏è Trade n√£o executado: ${signal.action} (${signal.confidence}%) - ${reason}`, 'info');
                    }
                } catch (error) {
                    this.log(`‚ùå Erro na an√°lise: ${error.message}`, 'error');
                }
            }

            async generateSignal() {
                const pair = document.getElementById('pair').value;
                
                try {
                    // Usar an√°lise t√©cnica real
                    const token = this.getAuthToken();
                    if (!token) {
                        return this.generateFallbackSignal(pair);
                    }

                    // Buscar an√°lise t√©cnica em tempo real
                    const response = await fetch(`${this.apiBase}/realtime-analysis/status`, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });

                    if (response.ok) {
                        const result = await response.json();
                        
                        if (result.status === 'success' && result.data && result.data.lastAnalysis && result.data.lastAnalysis.results) {
                            // Procurar sinal para o par atual
                            const signalForPair = result.data.lastAnalysis.results.find(s => s.symbol === pair);
                            
                            if (signalForPair && signalForPair.confidence > 20) { // Reduzido para 20% para mais trades
                                this.log(`üéØ Sinal t√©cnico: ${signalForPair.action} ${pair} (${signalForPair.confidence}%) - Risco: ${signalForPair.riskLevel}`, 'info');
                                
                                return {
                                    action: signalForPair.action,
                                    confidence: signalForPair.confidence,
                                    reason: `An√°lise t√©cnica: RSI, MACD, MHI, Bollinger Bands`,
                                    riskLevel: signalForPair.riskLevel
                                };
                            }
                        }
                    }
                    
                    // Se n√£o h√° sinal t√©cnico dispon√≠vel, usar an√°lise simples
                    return this.generateFallbackSignal(pair);
                } catch (error) {
                    this.log(`‚ö†Ô∏è Erro na an√°lise t√©cnica: ${error.message}`, 'error');
                    return this.generateFallbackSignal(pair);
                }
            }

            generateFallbackSignal(pair) {
                // An√°lise simples baseada em tend√™ncia simulada
                const actions = ['BUY', 'SELL', 'HOLD'];
                const action = actions[Math.floor(Math.random() * actions.length)];
                const confidence = 0.6 + Math.random() * 0.3; // 60-90% para garantir execu√ß√£o
                
                this.log(`üé≤ Fallback: ${action} ${pair} (${(confidence * 100).toFixed(0)}%)`, 'info');
                
                return {
                    symbol: pair || 'BTCUSD',
                    action: action,
                    confidence: confidence * 100, // Converter para porcentagem
                    riskLevel: 'MEDIUM'
                };
            }

            async executeTrade(signal) {
                // Verificar limites di√°rios
                if (this.dailyStats.trades >= (this.config.maxDailyTrades || 50)) {
                    this.log(`‚ö†Ô∏è Limite di√°rio de trades atingido: ${this.dailyStats.trades}/${this.config.maxDailyTrades}`, 'warning');
                    return;
                }

                // Verificar hor√°rios de trading
                if (!this.isWithinTradingHours()) {
                    this.log(`‚ö†Ô∏è Fora do hor√°rio de trading: ${this.config.tradingHoursStart} - ${this.config.tradingHoursEnd}`, 'warning');
                    return;
                }

                // Calcular valor do trade com martingale
                const baseAmount = this.config.tradeAmount || parseFloat(document.getElementById('amount').value);
                const amount = this.calculateTradeAmount(baseAmount);
                
                this.log(`üéØ Executando trade: ${signal.action} ${signal.symbol} $${amount} (Martingale: ${this.martingaleLevel})`, 'info');

                let trade;
                
                if (this.derivConnected) {
                    // Executar trade real na Deriv
                    trade = await this.executeRealTrade(signal, amount);
                } else {
                    // Simular trade
                    trade = await this.simulateTrade(signal, amount);
                }

                if (trade) {
                    // Adicionar trade ativo para monitoramento
                    this.activeTrades.set(trade.id, {
                        ...trade,
                        startTime: new Date(),
                        stopWin: this.config.stopWin || 50,
                        stopLoss: this.config.stopLoss || 100
                    });

                    // Adicionar trade
                    this.trades.unshift(trade);
                    
                    // Atualizar estat√≠sticas
                    this.updateStats(trade);
                    
                    // Verificar stop win/stop loss
                    this.checkStopWinLoss();
                    
                    // Atualizar martingale
                    this.updateMartingale(trade);
                    
                    // Atualizar saldo real se for trade real
                    if (trade.realTrade && this.derivConnected) {
                        await this.updateBalance();
                    }
                    
                    // Atualizar interface
                    this.updateTradesList();
                    this.updateUI();

                    // Log do trade com estrat√©gias
                    const strategies = signal.strategiesUsed || ['IA'];
                    this.logTrade(signal, trade, strategies);
                }
            }

            // Adicionar trade √† fila
            addTradeToQueue(signal) {
                // Verificar se j√° existe um trade similar na fila
                const existingTrade = this.tradeQueue.find(t => t.symbol === signal.symbol && t.action === signal.action);
                if (existingTrade) {
                    this.log(`‚ö†Ô∏è Trade similar j√° na fila: ${signal.action} ${signal.symbol}`, 'warning');
                    return;
                }

                this.tradeQueue.push({
                    ...signal,
                    timestamp: Date.now(),
                    id: `trade_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                });

                this.log(`üìã Trade adicionado √† fila (${this.tradeQueue.length} pendentes)`, 'info');
                
                // Processar fila se n√£o estiver executando
                if (!this.isExecutingTrade) {
                    this.processTradeQueue();
                }
            }

            // Processar fila de trades
            async processTradeQueue() {
                if (this.isExecutingTrade || this.tradeQueue.length === 0) {
                    return;
                }

                // Verificar cooldown
                const now = Date.now();
                if (now - this.lastTradeTime < this.tradeCooldown) {
                    const remainingTime = Math.ceil((this.tradeCooldown - (now - this.lastTradeTime)) / 1000);
                    this.log(`‚è≥ Aguardando cooldown: ${remainingTime}s restantes`, 'info');
                    setTimeout(() => this.processTradeQueue(), this.tradeCooldown - (now - this.lastTradeTime));
                    return;
                }

                this.isExecutingTrade = true;
                const trade = this.tradeQueue.shift(); // Remove o primeiro da fila

                try {
                    this.log(`üéØ Processando trade da fila: ${trade.action} ${trade.symbol}`, 'info');
                    await this.executeTrade(trade);
                } catch (error) {
                    this.log(`‚ùå Erro ao executar trade da fila: ${error.message}`, 'error');
                } finally {
                    this.isExecutingTrade = false;
                    this.lastTradeTime = Date.now();
                    
                    // Processar pr√≥ximo trade da fila ap√≥s um delay
                    setTimeout(() => this.processTradeQueue(), 2000);
                }
            }

            // Verificar se est√° dentro do hor√°rio de trading
            isWithinTradingHours() {
                if (!this.config.tradingHoursStart || !this.config.tradingHoursEnd) {
                    return true; // Se n√£o configurado, permitir sempre
                }

                const now = new Date();
                const currentTime = now.getHours() * 60 + now.getMinutes();
                
                const [startHour, startMin] = this.config.tradingHoursStart.split(':').map(Number);
                const [endHour, endMin] = this.config.tradingHoursEnd.split(':').map(Number);
                
                const startTime = startHour * 60 + startMin;
                const endTime = endHour * 60 + endMin;
                
                return currentTime >= startTime && currentTime <= endTime;
            }

            // Calcular valor do trade com martingale
            calculateTradeAmount(baseAmount) {
                if (!this.config.martingaleEnabled || this.martingaleLevel === 0) {
                    return baseAmount;
                }

                const multiplier = Math.pow(this.config.martingaleMultiplier || 2.0, this.martingaleLevel);
                return baseAmount * multiplier;
            }

            // Verificar stop win e stop loss
            checkStopWinLoss() {
                const currentProfit = this.dailyStats.profit;
                const stopWin = this.config.stopWin || 50;
                const stopLoss = this.config.stopLoss || 100;

                if (currentProfit >= stopWin) {
                    this.log(`üéØ STOP WIN atingido: $${currentProfit} >= $${stopWin}`, 'success');
                    this.stop();
                    return true;
                }

                if (currentProfit <= -stopLoss) {
                    this.log(`üõë STOP LOSS atingido: $${currentProfit} <= -$${stopLoss}`, 'error');
                    this.stop();
                    return true;
                }

                return false;
            }

            // Atualizar martingale baseado no resultado do trade
            updateMartingale(trade) {
                if (!this.config.martingaleEnabled) {
                    this.martingaleLevel = 0;
                    this.consecutiveLosses = 0;
                    return;
                }

                if (trade.profit > 0) {
                    // Trade vencedor - resetar martingale
                    this.martingaleLevel = 0;
                    this.consecutiveLosses = 0;
                    this.log(`‚úÖ Trade vencedor - Martingale resetado`, 'success');
                } else {
                    // Trade perdedor - incrementar martingale
                    this.consecutiveLosses++;
                    
                    if (this.consecutiveLosses <= (this.config.maxMartingaleLevels || 3)) {
                        this.martingaleLevel = this.consecutiveLosses;
                        this.log(`üìà Martingale n√≠vel ${this.martingaleLevel} (Perdas: ${this.consecutiveLosses})`, 'warning');
                        
                        // Se h√° trades na fila, processar ap√≥s um delay para permitir que o martingale seja aplicado
                        if (this.tradeQueue.length > 0) {
                            setTimeout(() => this.processTradeQueue(), 3000);
                        }
                    } else {
                        this.log(`üõë M√°ximo de n√≠veis de martingale atingido - Parando trading`, 'error');
                        this.stop();
                    }
                }
            }

            async executeRealTrade(signal, amount) {
                try {
                    const token = this.getAuthToken();
                    if (!token) {
                        this.log('‚ùå Token de autentica√ß√£o n√£o encontrado', 'error');
                        return null;
                    }

                    const tradeData = {
                        pair: signal.symbol,
                        type: signal.action,
                        amount: amount,
                        duration: 10, // 10 ticks
                        duration_type: 't'
                    };

                    this.log(`üîÑ Executando trade REAL na Deriv...`, 'info');

                    this.log(`üì§ Enviando dados do trade: ${JSON.stringify(tradeData)}`, 'info');
                    const response = await fetch(`${this.apiBase}/deriv/execute-trade`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify(tradeData)
                    });

                    this.log(`üì° Resposta do trade: ${response.status} ${response.statusText}`, 'info');
                    const responseText = await response.text();
                    this.log(`üìã Resposta bruta: ${responseText.substring(0, 200)}...`, 'info');
                    
                    let result;
                    try {
                        result = JSON.parse(responseText);
                    } catch (parseError) {
                        this.log(`‚ùå Erro ao fazer parse JSON: ${parseError.message}`, 'error');
                        return null;
                    }

                    if (response.ok && result.status === 'success') {
                        const tradeResult = result.data;
                        
                        // Calcular profit baseado no resultado do trade
                        const profit = parseFloat(tradeResult.profit || 0);
                        const isWin = profit > 0;
                        
                        return {
                            id: tradeResult.id || tradeResult.contract_id || Date.now(),
                            symbol: tradeData.pair,
                            action: tradeData.type,
                            amount: tradeData.amount,
                            profit: profit,
                            time: new Date().toLocaleTimeString(),
                            isWin: isWin,
                            contractId: tradeResult.contract_id || tradeResult.id,
                            realTrade: true
                        };
                    } else {
                        this.log(`‚ùå Erro no trade real: ${result.message}`, 'error');
                        return null;
                    }
                } catch (error) {
                    this.log(`‚ùå Erro na execu√ß√£o real: ${error.message}`, 'error');
                    return null;
                }
            }

            async simulateTrade(signal, amount) {
                // Simular execu√ß√£o
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Simular resultado (70% chance de ganho)
                const isWin = Math.random() < 0.7;
                const profit = isWin ? 
                    amount * (0.8 + Math.random() * 0.4) : 
                    -amount * (0.6 + Math.random() * 0.4);

                return {
                    id: Date.now(),
                    symbol: signal.symbol,
                    action: signal.action,
                    amount: amount,
                    profit: profit,
                    time: new Date().toLocaleTimeString(),
                    isWin: isWin,
                    realTrade: false
                };
            }

            updateStats(trade) {
                this.stats.totalTrades = (this.stats.totalTrades || 0) + 1;
                this.stats.totalProfit = (this.stats.totalProfit || 0) + (trade.profit || 0);
                
                // Atualizar estat√≠sticas di√°rias
                this.dailyStats.trades = (this.dailyStats.trades || 0) + 1;
                this.dailyStats.profit = (this.dailyStats.profit || 0) + (trade.profit || 0);
                
                if (trade.isWin) {
                    this.stats.winningTrades = (this.stats.winningTrades || 0) + 1;
                }

                this.stats.winRate = this.stats.totalTrades > 0 ? 
                    ((this.stats.winningTrades || 0) / this.stats.totalTrades) * 100 : 0;
            }

            updateStatus(status) {
                const indicator = document.getElementById('status-indicator');
                
                if (status === 'running') {
                    indicator.className = 'status-indicator status-running pulse';
                    indicator.textContent = 'üü¢ RODANDO';
                    document.getElementById('start-btn').disabled = true;
                    document.getElementById('stop-btn').disabled = false;
                } else {
                    indicator.className = 'status-indicator status-stopped';
                    indicator.textContent = 'üî¥ PARADO';
                    document.getElementById('start-btn').disabled = false;
                    document.getElementById('stop-btn').disabled = true;
                }
            }

            updateUI() {
                document.getElementById('total-trades').textContent = this.stats.totalTrades || 0;
                document.getElementById('win-rate').textContent = `${(this.stats.winRate || 0).toFixed(1)}%`;
                document.getElementById('profit').textContent = `$${(this.stats.totalProfit || 0).toFixed(2)}`;
                document.getElementById('daily-profit').textContent = `$${(this.dailyStats.profit || 0).toFixed(2)}`;
                document.getElementById('active-trades').textContent = this.activeTrades.size || 0;
                document.getElementById('martingale-level').textContent = this.martingaleLevel || 0;
                document.getElementById('queue-size').textContent = this.tradeQueue.length || 0;
                
                // Atualizar saldo baseado na conex√£o Deriv
                if (this.derivConnected && this.realBalance > 0) {
                    document.getElementById('balance').textContent = `$${this.realBalance.toFixed(2)}`;
                } else {
                    document.getElementById('balance').textContent = `$${(1000 + (this.stats.totalProfit || 0)).toFixed(2)}`;
                }
            }

            async checkDerivConnection() {
                try {
                    const token = this.getAuthToken();
                    this.log(`üîç Verificando token de autentica√ß√£o: ${token ? 'Encontrado' : 'N√£o encontrado'}`, 'info');
                    
                    if (!token) {
                        this.updateDerivStatus(false, 'Token n√£o encontrado');
                        this.log('‚ùå Token de autentica√ß√£o n√£o encontrado', 'error');
                        return;
                    }

                    this.log(`üîÑ Fazendo requisi√ß√£o para /auth/profile...`, 'info');
                    const response = await fetch(`${this.apiBase}/auth/profile`, {
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });

                    this.log(`üì° Resposta recebida: ${response.status} ${response.statusText}`, 'info');
                    const result = await response.json();
                    this.log(`üìã Dados do perfil:`, 'info');
                    this.log(JSON.stringify(result, null, 2), 'info');

                    this.log(`üîç Verificando condi√ß√µes: response.ok=${response.ok}, result.status=${result.status}`, 'info');
                    
                    if (response.ok && result.status === 'success') {
                        const user = result.data.user || result.data;
                        this.log(`üîç Token Deriv encontrado: ${user.deriv_api_token}`, 'info');
                        const hasDerivToken = user.deriv_api_token && user.deriv_api_token !== '';
                        
                        if (hasDerivToken) {
                            this.derivConnected = true;
                            this.updateDerivStatus(true, 'Conectado');
                            this.log('üîó Sistema conectado - Trades ativos', 'success');
                        } else {
                            this.derivConnected = false;
                            this.updateDerivStatus(false, 'Desconectado');
                            this.log('‚ö†Ô∏è Sistema desconectado - Modo SIMULADO', 'error');
                        }
                    } else {
                        this.derivConnected = false;
                        this.updateDerivStatus(false, 'Erro na verifica√ß√£o');
                        this.log(`‚ùå Deriv: Condi√ß√£o n√£o atendida - response.ok: ${response.ok}, result.status: ${result.status}`, 'error');
                    }
                } catch (error) {
                    this.derivConnected = false;
                    this.updateDerivStatus(false, 'Erro de conex√£o');
                    this.log(`‚ùå Deriv: Erro de conex√£o - ${error.message}`, 'error');
                }
            }

            updateDerivStatus(connected, message) {
                const element = document.getElementById('deriv-connection');
                if (connected) {
                    element.textContent = `‚úÖ ${message}`;
                    element.className = 'deriv-connected';
                } else {
                    element.textContent = `‚ùå ${message}`;
                    element.className = 'deriv-disconnected';
                }
            }

            async updateBalance() {
                try {
                    const token = this.getAuthToken();
                    if (!token || !this.derivConnected) {
                        this.log('‚ö†Ô∏è Token ou conex√£o Deriv n√£o dispon√≠vel para atualizar saldo', 'info');
                        return;
                    }

                    this.log('üîÑ Buscando saldo real da Deriv...', 'info');
                    const response = await fetch(`${this.apiBase}/deriv/balance`, {
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });

                    this.log(`üì° Resposta do saldo: ${response.status} ${response.statusText}`, 'info');
                    const result = await response.json();
                    this.log(`üìã Dados do saldo:`, 'info');
                    this.log(JSON.stringify(result, null, 2), 'info');

                    if (response.ok && result.status === 'success') {
                        this.realBalance = parseFloat(result.data.balance) || 0;
                        this.log(`üí∞ Saldo Deriv atualizado: $${this.realBalance.toFixed(2)}`, 'success');
                    } else {
                        this.log(`‚ö†Ô∏è Erro ao obter saldo Deriv: ${result.message || 'Erro desconhecido'}`, 'error');
                    }
                } catch (error) {
                    this.log(`‚ùå Erro ao atualizar saldo: ${error.message}`, 'error');
                }
            }

            getAuthToken() {
                // Tentar obter token do authManager se dispon√≠vel
                if (window.authManager && window.authManager.token) {
                    this.log('üîë Token obtido do authManager', 'info');
                    return window.authManager.token;
                }
                
                // Fallback para localStorage
                const localToken = localStorage.getItem('token');
                this.log(`üîë Token obtido do localStorage: ${localToken ? 'Encontrado' : 'N√£o encontrado'}`, 'info');
                return localToken;
            }

            updateTradesList() {
                const container = document.getElementById('trades-list');
                
                if (this.trades.length === 0) {
                    container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">Nenhum trade executado</div>';
                    return;
                }

                const recentTrades = this.trades.slice(0, 10);
                container.innerHTML = recentTrades.map(trade => `
                    <div class="trade-item ${trade.isWin ? 'trade-win' : 'trade-loss'}">
                        <div>
                            <strong>${trade.symbol}</strong> ${trade.action} $${trade.amount}
                            ${trade.realTrade ? '<span style="color: #00ff88;">üîó REAL</span>' : '<span style="color: #666;">üéÆ SIM</span>'}
                            <br><small>${trade.time}</small>
                        </div>
                        <div style="font-weight: bold; color: ${trade.isWin ? '#00ff88' : '#ff4444'};">
                            ${trade.profit > 0 ? '+' : ''}$${trade.profit.toFixed(2)}
                        </div>
                    </div>
                `).join('');
            }

            log(message, type = 'info', forceShow = false) {
                // Em modo produ√ß√£o, s√≥ mostra logs importantes
                if (this.productionMode && !forceShow) {
                    const criticalKeywords = ['üí∞', 'üéØ', '‚úÖ', '‚ùå', 'üöÄ', '‚èπÔ∏è', 'üìä', 'üîç', 'üí∏', 'üìà', 'üìâ'];
                    const criticalMessages = [
                        'Trade executado', 'Resultado:', 'Ganhou', 'Perdeu', 
                        'Saldo Deriv atualizado', 'Trading autom√°tico iniciado', 
                        'Trading autom√°tico parado', 'Sinal:', 'An√°lise IA:',
                        'BUY', 'SELL', 'HOLD', 'Confian√ßa:', 'Profit:', 'Loss:'
                    ];
                    
                    const isCritical = criticalKeywords.some(keyword => message.includes(keyword)) || 
                                     criticalMessages.some(critical => message.includes(critical)) ||
                                     type === 'error' || type === 'success';
                    
                    if (!isCritical) return;
                }

                const container = document.getElementById('logs');
                const time = new Date().toLocaleTimeString();
                
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                entry.innerHTML = `
                    <span class="log-time">[${time}]</span>
                    <span class="log-${type}">${message}</span>
                `;
                
                container.appendChild(entry);
                container.scrollTop = container.scrollHeight;

                // Manter apenas os √∫ltimos 50 logs
                const logs = container.querySelectorAll('.log-entry');
                if (logs.length > 50) {
                    logs[0].remove();
                }
            }

            logTrade(signal, trade, strategies = []) {
                const type = trade.isWin ? 'success' : 'error';
                const icon = trade.isWin ? '‚úÖ' : '‚ùå';
                const result = trade.isWin ? 'WIN' : 'LOSS';
                const strategiesText = strategies.length > 0 ? ` (${strategies.join(', ')})` : '';
                
                const message = `${icon} ${signal.action} ${signal.symbol} $${trade.amount} ‚Üí ${result} $${trade.profit.toFixed(2)}${strategiesText}`;
                this.log(message, type, true);
            }

            // M√©todos para an√°lise em tempo real
            async startRealtimeAnalysis() {
                try {
                    const token = this.getAuthToken();
                    if (!token) {
                        this.log('‚ùå Token n√£o encontrado para an√°lise em tempo real', 'error');
                        return;
                    }

                    const response = await fetch(`${this.apiBase}/realtime-analysis/start`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            intervalSeconds: 10,
                            symbols: ['R_10', 'R_25', 'R_50']
                        })
                    });

                    const result = await response.json();
                    if (result.status === 'success') {
                        this.realtimeAnalysisActive = true;
                        this.log('üîç An√°lise em tempo real iniciada', 'success');
                        
                        // Iniciar stream de dados
                        this.startAnalysisStream();
                    } else {
                        this.log('‚ùå Erro ao iniciar an√°lise em tempo real: ' + result.message, 'error');
                    }
                } catch (error) {
                    this.log('‚ùå Erro ao iniciar an√°lise em tempo real: ' + error.message, 'error');
                }
            }

            stopRealtimeAnalysis() {
                if (!this.realtimeAnalysisActive) return;

                try {
                    const token = this.getAuthToken();
                    if (!token) return;

                    fetch(`${this.apiBase}/realtime-analysis/stop`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    this.realtimeAnalysisActive = false;
                    this.log('üõë An√°lise em tempo real parada', 'info');
                } catch (error) {
                    console.error('Erro ao parar an√°lise em tempo real:', error);
                }
            }

            async startAnalysisStream() {
                try {
                    const token = this.getAuthToken();
                    if (!token) return;

                    const response = await fetch(`${this.apiBase}/realtime-analysis/stream`, {
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });

                    if (!response.ok) {
                        throw new Error('Erro ao conectar ao stream');
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();

                    while (this.realtimeAnalysisActive) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');

                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.slice(6));
                                    this.handleRealtimeAnalysis(data);
                                } catch (e) {
                                    // Ignorar linhas inv√°lidas
                                }
                            }
                        }
                    }
                } catch (error) {
                    if (this.realtimeAnalysisActive) {
                        this.log('‚ùå Erro no stream de an√°lise: ' + error.message, 'error');
                        // Tentar reconectar em 5 segundos
                        setTimeout(() => {
                            if (this.realtimeAnalysisActive) {
                                this.startAnalysisStream();
                            }
                        }, 5000);
                    }
                }
            }

            handleRealtimeAnalysis(data) {
                if (data.type === 'analysis' && data.data) {
                    const analysis = data.data;
                    this.lastAnalysisTime = new Date(analysis.timestamp);
                    
                    // Log apenas sinais importantes (confian√ßa > 60%)
                    if (analysis.results && analysis.results.length > 0) {
                        const strongSignals = analysis.results.filter(r => r.confidence > 60);
                        if (strongSignals.length > 0) {
                            strongSignals.forEach(signal => {
                                this.log(`üéØ ${signal.symbol}: ${signal.action} (${signal.confidence}%) - Risco: ${signal.riskLevel}`, 'info');
                                
                                // Mostrar indicadores t√©cnicos
                                if (signal.indicators) {
                                    const indicators = signal.indicators;
                                    this.log(`üìä RSI: ${indicators.rsi?.value?.toFixed(1) || 'N/A'} | MACD: ${indicators.macd?.trend || 'N/A'} | MHI: ${indicators.mhi?.value?.toFixed(2) || 'N/A'}`, 'info');
                                }
                            });
                        }
                    }

                    // Log sentimento do mercado se mudou significativamente
                    if (analysis.marketSentiment && analysis.marketSentiment !== 'NEUTRAL') {
                        this.log(`üåç Sentimento do mercado: ${analysis.marketSentiment} (${analysis.trend})`, 'info');
                    }
                }
            }
        }

        // Sistema de Notifica√ß√µes Profissionais
        function showNotification(message, type = 'info', title = null) {
            const container = document.getElementById('notification-container');
            if (!container) return;

            const notification = document.createElement('div');
            notification.className = `notification ${type}`;

            const icons = {
                success: '‚úÖ',
                error: '‚ùå',
                warning: '‚ö†Ô∏è',
                info: '‚ÑπÔ∏è'
            };

            const titles = {
                success: 'Sucesso',
                error: 'Erro',
                warning: 'Aten√ß√£o',
                info: 'Informa√ß√£o'
            };

            notification.innerHTML = `
                <div class="notification-icon">${icons[type] || icons.info}</div>
                <div class="notification-content">
                    <div class="notification-title">${title || titles[type] || titles.info}</div>
                    <div class="notification-message">${message}</div>
                </div>
                <button class="notification-close" onclick="this.parentElement.remove()">√ó</button>
            `;

            container.appendChild(notification);

            // Animar entrada
            setTimeout(() => {
                notification.classList.add('show');
            }, 100);

            // Auto-remover ap√≥s 5 segundos
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.classList.remove('show');
                    setTimeout(() => {
                        if (notification.parentElement) {
                            notification.remove();
                        }
                    }, 300);
                }
            }, 5000);
        }

        // Fun√ß√£o global para trocar conta
        async function switchAccount() {
            if (!window.titan) {
                showNotification('Sistema n√£o inicializado', 'error');
                return;
            }
            
            try {
                const token = window.titan.getAuthToken();
                if (!token) {
                    showNotification('Token de autentica√ß√£o n√£o encontrado', 'error');
                    return;
                }

                // Obter configura√ß√£o atual
                const response = await fetch(`${window.titan.apiBase}/deriv-config/config`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                const result = await response.json();
                if (result.status !== 'success') {
                    showNotification('Erro ao obter configura√ß√£o atual', 'error');
                    return;
                }

                const currentType = result.data.accountType || 'demo';
                const newType = currentType === 'demo' ? 'real' : 'demo';

                // Verificar se a nova conta tem token configurado
                const hasToken = newType === 'demo' 
                    ? result.data.hasDemoToken 
                    : result.data.hasRealToken;

                if (!hasToken) {
                    const newLabel = newType === 'demo' ? 'DEMO' : 'REAL';
                    showNotification(`Token da conta ${newLabel} n√£o configurado. Configure primeiro em /deriv-tokens.html`, 'warning');
                    return;
                }

                // Confirmar troca
                const currentLabel = currentType === 'demo' ? 'DEMO' : 'REAL';
                const newLabel = newType === 'demo' ? 'DEMO' : 'REAL';
                const confirmMsg = `Trocar de conta ${currentLabel} para ${newLabel}?`;
                if (!confirm(confirmMsg)) {
                    return;
                }

                // Atualizar tipo de conta
                const updateResponse = await fetch(`${window.titan.apiBase}/deriv-config/config`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        accountType: newType
                    })
                });

                const updateResult = await updateResponse.json();
                if (updateResult.status === 'success') {
                    showNotification(`Conta alterada para ${newLabel}! Recarregando...`, 'success');
                    setTimeout(() => location.reload(), 2000);
                } else {
                    showNotification('Erro ao alterar conta: ' + updateResult.message, 'error');
                }

            } catch (error) {
                console.error('Erro ao trocar conta:', error);
                showNotification('Erro ao trocar conta: ' + error.message, 'error');
            }
        }

        // Sistema de Configura√ß√µes do Cliente
        class ClientConfigManager {
            constructor(titanInstance) {
                this.config = {};
                this.isLoading = false;
                this.titan = titanInstance;
            }

            async loadConfig() {
                try {
                    const token = this.titan.getAuthToken() || localStorage.getItem('authToken');
                    if (!token) {
                        console.error('Token n√£o encontrado');
                        return;
                    }

                    const response = await fetch(`${this.titan.apiBase}/client-config/config`, {
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    const result = await response.json();
                    if (result.status === 'success') {
                        this.config = result.data;
                        this.populateForm();
                        console.log('‚úÖ Configura√ß√µes carregadas:', this.config);
                    } else {
                        console.error('Erro ao carregar configura√ß√µes:', result.message);
                    }
                } catch (error) {
                    console.error('Erro ao carregar configura√ß√µes:', error);
                }
            }

            populateForm() {
                // Risk Management
                document.getElementById('stop-win').value = this.config.stopWin || 50;
                document.getElementById('stop-loss').value = this.config.stopLoss || 100;
                document.getElementById('risk-per-trade').value = this.config.riskPerTrade || 1;

                // Martingale
                document.getElementById('martingale-enabled').checked = this.config.martingaleEnabled || false;
                document.getElementById('martingale-multiplier').value = this.config.martingaleMultiplier || 2.0;
                document.getElementById('max-martingale-levels').value = this.config.maxMartingaleLevels || 3;

                // Trading
                document.getElementById('trade-amount').value = this.config.tradeAmount || 5;
                document.getElementById('ticket-quantity').value = this.config.ticketQuantity || 10;
                document.getElementById('max-daily-trades').value = this.config.maxDailyTrades || 50;

                // Trading Pairs
                const tradingPairsSelect = document.getElementById('trading-pairs');
                if (this.config.tradingPairs && Array.isArray(this.config.tradingPairs)) {
                    Array.from(tradingPairsSelect.options).forEach(option => {
                        option.selected = this.config.tradingPairs.includes(option.value);
                    });
                }

                // IA
                document.getElementById('ai-confidence-threshold').value = this.config.aiConfidenceThreshold || 60;
                document.getElementById('ai-analysis-interval').value = this.config.aiAnalysisInterval || 10;
                document.getElementById('trade-cooldown').value = this.config.tradeCooldown || 5;
                document.getElementById('auto-trading-enabled').checked = this.config.autoTradingEnabled || false;

                // Hor√°rios
                document.getElementById('trading-hours-start').value = this.config.tradingHoursStart || '00:00';
                document.getElementById('trading-hours-end').value = this.config.tradingHoursEnd || '23:59';
            }

            async saveConfig() {
                if (this.isLoading) return;
                this.isLoading = true;

                try {
                    const token = this.titan.getAuthToken() || localStorage.getItem('authToken');
                    if (!token) {
                        showNotification('Token n√£o encontrado', 'error');
                        return;
                    }

                    // Coletar dados do formul√°rio
                    const configData = {
                        stopWin: parseFloat(document.getElementById('stop-win').value),
                        stopLoss: parseFloat(document.getElementById('stop-loss').value),
                        riskPerTrade: parseFloat(document.getElementById('risk-per-trade').value),
                        martingaleEnabled: document.getElementById('martingale-enabled').checked,
                        martingaleMultiplier: parseFloat(document.getElementById('martingale-multiplier').value),
                        maxMartingaleLevels: parseInt(document.getElementById('max-martingale-levels').value),
                        tradeAmount: parseFloat(document.getElementById('trade-amount').value),
                        ticketQuantity: parseInt(document.getElementById('ticket-quantity').value),
                        maxDailyTrades: parseInt(document.getElementById('max-daily-trades').value),
                        tradingPairs: Array.from(document.getElementById('trading-pairs').selectedOptions).map(option => option.value),
                        aiConfidenceThreshold: parseInt(document.getElementById('ai-confidence-threshold').value),
                        aiAnalysisInterval: parseInt(document.getElementById('ai-analysis-interval').value),
                        tradeCooldown: parseInt(document.getElementById('trade-cooldown').value),
                        autoTradingEnabled: document.getElementById('auto-trading-enabled').checked,
                        tradingHoursStart: document.getElementById('trading-hours-start').value,
                        tradingHoursEnd: document.getElementById('trading-hours-end').value
                    };

                    const response = await fetch(`${this.titan.apiBase}/client-config/config`, {
                        method: 'PUT',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(configData)
                    });

                    const result = await response.json();
                    if (result.status === 'success') {
                        this.config = configData;
                        showNotification('Configura√ß√µes salvas com sucesso!', 'success');
                        console.log('‚úÖ Configura√ß√µes salvas:', configData);
                    } else {
                        showNotification('Erro ao salvar configura√ß√µes: ' + result.message, 'error');
                    }
                } catch (error) {
                    console.error('Erro ao salvar configura√ß√µes:', error);
                    showNotification('Erro ao salvar configura√ß√µes: ' + error.message, 'error');
                } finally {
                    this.isLoading = false;
                }
            }

            async resetConfig() {
                if (confirm('Tem certeza que deseja resetar todas as configura√ß√µes para o padr√£o?')) {
                    try {
                        const token = this.titan.getAuthToken() || localStorage.getItem('authToken');
                        if (!token) {
                            showNotification('Token n√£o encontrado', 'error');
                            return;
                        }

                        const response = await fetch(`${this.titan.apiBase}/client-config/reset`, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${token}`,
                                'Content-Type': 'application/json'
                            }
                        });

                        const result = await response.json();
                        if (result.status === 'success') {
                            showNotification('Configura√ß√µes resetadas para o padr√£o!', 'success');
                            await this.loadConfig();
                        } else {
                            showNotification('Erro ao resetar configura√ß√µes: ' + result.message, 'error');
                        }
                    } catch (error) {
                        console.error('Erro ao resetar configura√ß√µes:', error);
                        showNotification('Erro ao resetar configura√ß√µes: ' + error.message, 'error');
                    }
                }
            }

            toggleConfigPanel() {
                const panel = document.getElementById('config-panel');
                if (panel.style.display === 'none') {
                    panel.style.display = 'block';
                    this.loadConfig();
                } else {
                    panel.style.display = 'none';
                }
            }
        }

        // Inst√¢ncia global do gerenciador de configura√ß√µes (ser√° inicializada ap√≥s o titan)
        let clientConfigManager;

        // Inicializar quando carregar
        document.addEventListener('DOMContentLoaded', async () => {
            const titan = new TitanSimple();
            await titan.init();
            window.titan = titan; // Para debug
            
            // Inicializar o gerenciador de configura√ß√µes com a inst√¢ncia do titan
            clientConfigManager = new ClientConfigManager(titan);
            
            // Fun√ß√£o para verificar Deriv quando authManager estiver pronto
            const checkDerivWhenReady = () => {
                if (window.authManager && window.authManager.token) {
                    titan.log('üîÑ AuthManager pronto - verificando Deriv...', 'info');
                    titan.checkDerivConnection().then(() => {
                        titan.updateBalance().then(() => {
                            titan.updateUI();
                        });
                    });
                } else {
                    // Tentar novamente em 500ms
                    setTimeout(checkDerivWhenReady, 500);
                }
            };
            
            // Iniciar verifica√ß√£o
            checkDerivWhenReady();

            // Event listeners para configura√ß√µes
            document.getElementById('config-btn').addEventListener('click', () => {
                if (clientConfigManager) {
                    clientConfigManager.toggleConfigPanel();
                } else {
                    console.error('ClientConfigManager n√£o inicializado');
                }
            });

            document.getElementById('save-config-btn').addEventListener('click', () => {
                if (clientConfigManager) {
                    clientConfigManager.saveConfig();
                } else {
                    console.error('ClientConfigManager n√£o inicializado');
                }
            });

            document.getElementById('reset-config-btn').addEventListener('click', () => {
                if (clientConfigManager) {
                    clientConfigManager.resetConfig();
                } else {
                    console.error('ClientConfigManager n√£o inicializado');
                }
            });

            document.getElementById('close-config-btn').addEventListener('click', () => {
                document.getElementById('config-panel').style.display = 'none';
            });
        });
    </script>
</body>
</html>
